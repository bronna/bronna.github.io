var ae=Object.defineProperty;var oe=(e,t,r)=>t in e?ae(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var g=(e,t,r)=>oe(e,typeof t!="symbol"?t+"":t,r);import{R as ce,P as ie,S as ue,W as de,a as j,A as _,C as le,T as fe}from"./wwKeP0Ca.js";import{c as he,a as me}from"./CR_3py8g.js";import{N as ge,aW as q,v as x,r as be,u as X,aM as J,T as pe,aX as y,aY as b,m as V,b as R,x as Q,A as xe,B as ye,D as ve,z as we}from"./CVuNfkzf.js";import{s as Se}from"./B29C6zgS.js";import{a as D,r as Ve}from"./DWvpJWiV.js";import{a as k,o as Y}from"./Dk5IxytF.js";import{g as N,w,d as P,r as Z}from"./VZ_jJvjc.js";function Ce(e){ge(e,e.v+1)}function Ee(e){let t=0,r=pe(0),s;return()=>{q()&&(x(r),be(()=>(t===0&&(s=X(()=>e(()=>Ce(r)))),t+=1,()=>{J().then(()=>{t-=1,t===0&&(s==null||s(),s=void 0)})})))}}function Me(e){let t;const r=Ee(n=>{let a=!1;const c=e.subscribe(i=>{t=i,a&&n()});return a=!0,c});function s(){return q()?(r(),t):N(e)}return"set"in e?{get current(){return s()},set current(n){e.set(n)}}:{get current(){return s()}}}const U=(e,t)=>{if(e===t)return!0;if(!e||!t)return!1;const r=e.length;if(t.length!==r)return!1;for(let s=0;s<r;s++)if(e[s]!==t[s])return!1;return!0},yt=()=>{const e=[],s={items:e,remember:(n,a)=>{for(let i=0;i<e.length;i++){const u=e[i];if(U(a,u.keys)&&u.promise)return u.promise}const c={promise:n(),keys:a};return e.push(c),c.promise},clear:n=>{for(let a=0;a<e.length;a++){const c=e[a];if(U(n,c.keys)){e.splice(a,1);return}}}};return y("threlte-cache",s),s},Re=()=>{const e=b("threlte-cache");if(!e)throw new Error("No cache found. The cache can only be used in a child component to <Canvas>.");return e},B=Symbol(),ke=e=>typeof(e==null?void 0:e.subscribe)=="function",F=(e,t,r)=>{const s=e().map(c=>ke(c)?Me(c):B),n=Q(()=>e().map((c,i)=>s[i]===B?c:s[i].current)),a=()=>{x(n);let c;return X(()=>{c=t(x(n))}),c};r?V(a):R(a)},Te=(e,t)=>F(e,t,!1),De=(e,t)=>F(e,t,!0),vt=Object.assign(Te,{pre:De}),C=(e,t)=>(e==null?void 0:e[`is${t}`])===!0,z=e=>{const t=w(void 0),r=w(void 0);return e.then(s=>{t.set(s)}).catch(s=>{console.error("Error in asyncWritable:",s.message),r.set(s)}),Object.assign(Object.assign(e,t),{error:r,promise:e})},Ae=typeof window<"u",Pe=ce.replace("dev",""),wt=Number.parseInt(Pe),v=(e,t)=>{const r=P(e,a=>a);let s;const n=r.subscribe(async a=>{s&&s();const c=await t(a);c&&(s=c)});k(()=>{n(),s&&s()})},E=e=>{const t=w(e),r={set:s=>{r.current=s,t.set(s)},subscribe:t.subscribe,update:s=>{const n=s(r.current);r.current=n,t.set(n)},current:e};return r},Oe=e=>({subscribe:e.subscribe,get current(){return e.current}}),$=(e,t)=>{if(t.includes(".")){const r=t.split("."),s=r.pop();for(let n=0;n<r.length;n+=1)e=e[r[n]];return{target:e,key:s}}else return{target:e,key:t}},St=e=>{const{dom:t,canvas:r}=e,s=E({width:t.offsetWidth,height:t.offsetHeight});Y(()=>{const a=new ResizeObserver(()=>{const{offsetWidth:c,offsetHeight:i}=t;(s.current.width!==c||s.current.height!==i)&&s.set({width:c,height:i})});return a.observe(t),()=>{a.disconnect()}});const n={dom:t,canvas:r,size:Oe(s)};return y("threlte-dom-context",n),n},L=()=>{const e=b("threlte-dom-context");if(!e)throw new Error("useDOM can only be used in a child component to <Canvas>.");return e};function Ie(e){return{all:e=e||new Map,on:function(t,r){var s=e.get(t);s?s.push(r):e.set(t,[r])},off:function(t,r){var s=e.get(t);s&&(r?s.splice(s.indexOf(r)>>>0,1):e.set(t,[]))},emit:function(t,r){var s=e.get(t);s&&s.slice().map(function(n){n(r)}),(s=e.get("*"))&&s.slice().map(function(n){n(t,r)})}}}class M{constructor(){g(this,"allVertices",{});g(this,"isolatedVertices",{});g(this,"connectedVertices",{});g(this,"sortedConnectedValues",[]);g(this,"needsSort",!1);g(this,"emitter",Ie());g(this,"emit",this.emitter.emit.bind(this.emitter));g(this,"on",this.emitter.on.bind(this.emitter));g(this,"off",this.emitter.off.bind(this.emitter));g(this,"getKey",t=>typeof t=="object"?t.key:t)}get sortedVertices(){return this.mapNodes(t=>t)}moveToIsolated(t){const r=this.connectedVertices[t];r&&(this.isolatedVertices[t]=r,delete this.connectedVertices[t])}moveToConnected(t){const r=this.isolatedVertices[t];r&&(this.connectedVertices[t]=r,delete this.isolatedVertices[t])}add(t,r,s){if(this.allVertices[t]&&this.allVertices[t].value!==void 0)throw new Error(`A node with the key ${t.toString()} already exists`);let n=this.allVertices[t];n?n.value===void 0&&(n.value=r):(n={value:r,previous:new Set,next:new Set},this.allVertices[t]=n);const a=n.next.size>0||n.previous.size>0;if(!(s!=null&&s.after)&&!(s!=null&&s.before)&&!a){this.isolatedVertices[t]=n,this.emit("node:added",{key:t,type:"isolated",value:r});return}else this.connectedVertices[t]=n;if(s!=null&&s.after){const c=Array.isArray(s.after)?s.after:[s.after];c.forEach(i=>{n.previous.add(this.getKey(i))}),c.forEach(i=>{const u=this.getKey(i),o=this.allVertices[u];o?(o.next.add(t),this.moveToConnected(u)):(this.allVertices[u]={value:void 0,previous:new Set,next:new Set([t])},this.connectedVertices[u]=this.allVertices[u])})}if(s!=null&&s.before){const c=Array.isArray(s.before)?s.before:[s.before];c.forEach(i=>{n.next.add(this.getKey(i))}),c.forEach(i=>{const u=this.getKey(i),o=this.allVertices[u];o?(o.previous.add(t),this.moveToConnected(u)):(this.allVertices[u]={value:void 0,previous:new Set([t]),next:new Set},this.connectedVertices[u]=this.allVertices[u])})}this.emit("node:added",{key:t,type:"connected",value:r}),this.needsSort=!0}remove(t){const r=this.getKey(t);if(this.isolatedVertices[r]){delete this.isolatedVertices[r],delete this.allVertices[r],this.emit("node:removed",{key:r,type:"isolated"});return}const n=this.connectedVertices[r];n&&(n.next.forEach(a=>{const c=this.connectedVertices[a];c&&(c.previous.delete(r),c.previous.size===0&&c.next.size===0&&this.moveToIsolated(a))}),n.previous.forEach(a=>{const c=this.connectedVertices[a];c&&(c.next.delete(r),c.previous.size===0&&c.next.size===0&&this.moveToIsolated(a))}),delete this.connectedVertices[r],delete this.allVertices[r],this.emit("node:removed",{key:r,type:"connected"}),this.needsSort=!0)}mapNodes(t){this.needsSort&&this.sort();const r=[];return this.forEachNode((s,n)=>{r.push(t(s,n))}),r}forEachNode(t){this.needsSort&&this.sort();let r=0;for(;r<this.sortedConnectedValues.length;r++)t(this.sortedConnectedValues[r],r);Reflect.ownKeys(this.isolatedVertices).forEach(s=>{const n=this.isolatedVertices[s];n.value!==void 0&&t(n.value,r++)})}getValueByKey(t){var r;return(r=this.allVertices[t])==null?void 0:r.value}getKeyByValue(t){return Reflect.ownKeys(this.connectedVertices).find(r=>this.connectedVertices[r].value===t)??Reflect.ownKeys(this.isolatedVertices).find(r=>this.isolatedVertices[r].value===t)}sort(){var c;const t=new Map,r=[],s=[],n=Reflect.ownKeys(this.connectedVertices).filter(i=>this.connectedVertices[i].value!==void 0);for(n.forEach(i=>{t.set(i,0)}),n.forEach(i=>{this.connectedVertices[i].next.forEach(o=>{this.connectedVertices[o]&&t.set(o,(t.get(o)||0)+1)})}),t.forEach((i,u)=>{i===0&&r.push(u)});r.length>0;){const i=r.shift();s.push(i);const u=n.find(o=>o===i);u&&((c=this.connectedVertices[u])==null||c.next.forEach(o=>{const l=(t.get(o)||0)-1;t.set(o,l),l===0&&r.push(o)}))}if(s.length!==n.length)throw new Error("The graph contains a cycle, and thus can not be sorted topologically.");const a=i=>i!==void 0;this.sortedConnectedValues=s.map(i=>this.connectedVertices[i].value).filter(a),this.needsSort=!1}clear(){this.allVertices={},this.isolatedVertices={},this.connectedVertices={},this.sortedConnectedValues=[],this.needsSort=!1}static isKey(t){return typeof t=="string"||typeof t=="symbol"}static isValue(t){return typeof t=="object"&&"key"in t}}class je{constructor(t,r,s){g(this,"key");g(this,"stage");g(this,"callback");g(this,"runTask",!0);this.stage=t,this.key=r,this.callback=s}stop(){this.runTask=!1}start(){this.runTask=!0}run(t){this.runTask&&this.callback(t)}}class ze extends M{constructor(r,s,n){super();g(this,"key");g(this,"scheduler");g(this,"runTask",!0);g(this,"callback",(r,s)=>s());g(this,"removeTask",this.remove.bind(this));this.scheduler=r,this.key=s,this.start=this.start.bind(this),this.stop=this.stop.bind(this),n&&(this.callback=n.bind(this))}stop(){this.runTask=!1}start(){this.runTask=!0}get tasks(){return this.sortedVertices}createTask(r,s,n){const a=new je(this,r,s);return this.add(r,a,n),a}getTask(r){return this.getValueByKey(r)}run(r){this.runTask&&this.callback(r,s=>{this.forEachNode(n=>{n.run(s??r)})})}runWithTiming(r){if(!this.runTask)return{};const s={};return this.callback(r,n=>{this.forEachNode(a=>{const c=performance.now();a.run(n??r);const i=performance.now()-c;s[a.key]=i})}),s}getSchedule(){return this.mapNodes(r=>r.key.toString())}}class Ke extends M{constructor(r){super();g(this,"lastTime",performance.now());g(this,"clampDeltaTo",.1);g(this,"removeStage",this.remove.bind(this));r!=null&&r.clampDeltaTo&&(this.clampDeltaTo=r.clampDeltaTo),this.run=this.run.bind(this)}get stages(){return this.sortedVertices}createStage(r,s){const n=new ze(this,r,s==null?void 0:s.callback);return this.add(r,n,{after:s==null?void 0:s.after,before:s==null?void 0:s.before}),n}getStage(r){return this.getValueByKey(r)}run(r){const s=r-this.lastTime;this.forEachNode(n=>{n.run(Math.min(s/1e3,this.clampDeltaTo))}),this.lastTime=r}runWithTiming(r){const s=r-this.lastTime,n={},a=performance.now();return this.forEachNode(c=>{const i=performance.now(),u=c.runWithTiming(Math.min(s/1e3,this.clampDeltaTo)),o=performance.now()-i;n[c.key.toString()]={duration:o,tasks:u}}),{total:performance.now()-a,stages:n}}getSchedule(r={tasks:!0}){return{stages:this.mapNodes(s=>{if(s===void 0)throw new Error("Stage not found");return{key:s.key.toString(),tasks:r.tasks?s.getSchedule():void 0}})}}dispose(){this.clear()}}const Vt=e=>{const t=new Ke,r=t.createStage(Symbol("threlte-main-stage")),s={scheduler:t,frameInvalidated:!0,autoInvalidations:new Set,shouldAdvance:!1,advance:()=>{s.shouldAdvance=!0},autoRender:E(e.autoRender??!0),renderMode:E(e.renderMode??"on-demand"),invalidate(){s.frameInvalidated=!0},mainStage:r,shouldRender:()=>s.renderMode.current==="always"||s.renderMode.current==="on-demand"&&(s.frameInvalidated||s.autoInvalidations.size>0)||s.renderMode.current==="manual"&&s.shouldAdvance,renderStage:t.createStage(Symbol("threlte-render-stage"),{after:r,callback(n,a){s.shouldRender()&&a()}}),resetFrameInvalidation(){s.frameInvalidated=!1,s.shouldAdvance=!1}};return R(()=>{s.autoRender.set(e.autoRender??!0)}),R(()=>{s.renderMode.set(e.renderMode??"on-demand")}),k(()=>{s.scheduler.dispose()}),y("threlte-scheduler-context",s),s},O=()=>{const e=b("threlte-scheduler-context");if(!e)throw new Error("useScheduler can only be used in a child component to <Canvas>.");return e},Ct=()=>{const{size:e}=L(),{invalidate:t}=O(),r=new ie(75,0,.1,1e3);r.position.z=5,r.lookAt(0,0,0);const s=E(r);v(e,a=>{if(s.current===r){const c=s.current;c.aspect=a.width/a.height,c.updateProjectionMatrix(),t()}});const n={camera:s};return y("threlte-camera-context",n),n},ee=()=>{const e=b("threlte-camera-context");if(!e)throw new Error("useCamera can only be used in a child component to <Canvas>.");return e},Et=()=>{const e={removeObjectFromDisposal:t=>{e.disposableObjects.delete(t)},disposableObjectMounted:t=>{const r=e.disposableObjects.get(t);r?e.disposableObjects.set(t,r+1):e.disposableObjects.set(t,1)},disposableObjectUnmounted:t=>{const r=e.disposableObjects.get(t);r&&r>0&&(e.disposableObjects.set(t,r-1),r-1<=0&&(e.shouldDispose=!0))},disposableObjects:new Map,shouldDispose:!1,dispose:async(t=!1)=>{await J(),!(!e.shouldDispose&&!t)&&(e.disposableObjects.forEach((r,s)=>{var n;(r===0||t)&&((n=s==null?void 0:s.dispose)==null||n.call(s),e.disposableObjects.delete(s))}),e.shouldDispose=!1)}};return k(()=>{e.dispose(!0)}),y("threlte-disposal-context",e),e},te=()=>{const e=b("threlte-disposal-context");if(!e)throw new Error("useDisposal can only be used in a child component to <Canvas>.");return e},re=Symbol("threlte-parent-context"),Ne=e=>{const t=E(e);return y(re,t),t},We=()=>b(re),A=Symbol("threlte-parent-object3d-context"),Mt=e=>{const t=Z(e);return y(A,t),t},Le=e=>{const t=b(A),r=w(e),s=P([r,t],([n,a])=>n??a);return y(A,s),r},_e=()=>b(A);function Ue(e,t,r){if(!Ae)return{task:void 0,start:()=>{},stop:()=>{},started:Z(!1)};let s,n,a;M.isKey(e)?(s=e,n=t,a=r):(s=Symbol("useTask"),n=e,a=t);const c=O();let i=c.mainStage;if(a){if(a.stage)if(M.isValue(a.stage))i=a.stage;else{const h=c.scheduler.getStage(a.stage);if(!h)throw new Error(`No stage found with key ${a.stage.toString()}`);i=h}else if(a.after)if(Array.isArray(a.after))for(let h=0;h<a.after.length;h++){const f=a.after[h];if(M.isValue(f)){i=f.stage;break}}else M.isValue(a.after)&&(i=a.after.stage);else if(a.before)if(Array.isArray(a.before))for(let h=0;h<a.before.length;h++){const f=a.before[h];if(M.isValue(f)){i=f.stage;break}}else M.isValue(a.before)&&(i=a.before.stage)}const u=w(!1),o=i.createTask(s,n,a),l=()=>{u.set(!0),((a==null?void 0:a.autoInvalidate)??!0)&&c.autoInvalidations.add(n),o.start()},d=()=>{u.set(!1),((a==null?void 0:a.autoInvalidate)??!0)&&c.autoInvalidations.delete(n),o.stop()};return(a==null?void 0:a.autoStart)??!0?l():d(),k(()=>{d(),i.removeTask(s)}),{task:o,start:l,stop:d,started:{subscribe:u.subscribe}}}const Rt=e=>{const t={scene:e||new ue};return y("threlte-scene-context",t),t},se=()=>{const e=b("threlte-scene-context");if(!e)throw new Error("useScene can only be used in a child component to <Canvas>.");return e},kt=e=>{const{dispose:t}=te(),{camera:r}=ee(),{scene:s}=se(),{invalidate:n,renderStage:a,autoRender:c,scheduler:i,resetFrameInvalidation:u}=O(),{size:o,canvas:l}=L(),d=e.createRenderer?e.createRenderer(l):new de({canvas:l,powerPreference:"high-performance",antialias:!0,alpha:!0}),h=a.createTask(Symbol("threlte-auto-render-task"),()=>{d.render(s,r.current)}),f={renderer:d,colorManagementEnabled:E(e.colorManagementEnabled??!0),colorSpace:E(e.colorSpace??"srgb"),dpr:E(e.dpr??window.devicePixelRatio),shadows:E(e.shadows??j),toneMapping:E(e.toneMapping??_),autoRenderTask:h};y("threlte-renderer-context",f),v([f.colorManagementEnabled],([m])=>{le.enabled=m}),v([f.colorSpace],([m])=>{"outputColorSpace"in d&&(d.outputColorSpace=m)}),v([f.dpr],([m])=>{"setPixelRatio"in d&&d.setPixelRatio(m)});const{start:S,stop:p}=Ue(()=>{var m;!("xr"in d)||(m=d.xr)!=null&&m.isPresenting||(d.setSize(o.current.width,o.current.height),n(),p())},{before:h,autoStart:!1,autoInvalidate:!1});return v([o],()=>{S()}),v([f.shadows],([m])=>{"shadowMap"in d&&(d.shadowMap.enabled=!!m,m&&m!==!0?d.shadowMap.type=m:m===!0&&(d.shadowMap.type=j))}),v([f.toneMapping],([m])=>{"toneMapping"in d&&(d.toneMapping=m)}),v([c],([m])=>(m?f.autoRenderTask.start():f.autoRenderTask.stop(),()=>{f.autoRenderTask.stop()})),"setAnimationLoop"in f.renderer&&f.renderer.setAnimationLoop(T=>{t(),i.run(T),u()}),k(()=>{if("dispose"in f.renderer){const m=f.renderer.dispose;m()}}),R(()=>{f.colorManagementEnabled.set(e.colorManagementEnabled??!0)}),R(()=>{f.colorSpace.set(e.colorSpace??"srgb")}),R(()=>{f.toneMapping.set(e.toneMapping??_)}),R(()=>{f.shadows.set(e.shadows??j)}),R(()=>{f.dpr.set(e.dpr??window.devicePixelRatio)}),f},Be=()=>{const e=b("threlte-renderer-context");if(!e)throw new Error("useRenderer can only be used in a child component to <Canvas>.");return e},Tt=()=>{const e=E({});return y("threlte-user-context",e),e},He=()=>{const e=b("threlte-user-context");if(!e)throw new Error("useUserContext can only be used in a child component to <Canvas>.");return e},I=()=>{const e=O(),t=Be(),r=ee(),s=se(),n=L();return{advance:e.advance,autoRender:e.autoRender,autoRenderTask:t.autoRenderTask,camera:r.camera,colorManagementEnabled:t.colorManagementEnabled,colorSpace:t.colorSpace,dpr:t.dpr,invalidate:e.invalidate,mainStage:e.mainStage,renderer:t.renderer,renderMode:e.renderMode,renderStage:e.renderStage,scheduler:e.scheduler,shadows:t.shadows,shouldRender:e.shouldRender,dom:n.dom,canvas:n.canvas,size:n.size,toneMapping:t.toneMapping,get scene(){return s.scene},set scene(c){s.scene=c}}},Ge=e=>typeof e=="object"&&e!==null,qe=()=>{const{invalidate:e}=I();let t;const r=w(),s=We(),n=_e(),a=Ne(),c=Le();v([r,a,s,n],([o,l,d,h])=>{if(t==null||t(),t=void 0,!l){e();return}if(o!==void 0){if(o){if(typeof o=="function")t=o({ref:l,parent:d,parentObject3D:h});else if(C(o,"Object3D")&&C(l,"Object3D"))t=()=>o==null?void 0:o.remove(l),o==null||o.add(l);else if(typeof o=="string"){const{target:f,key:S}=$(d,o),p=f[S];t=()=>f[S]=p,f[S]=l}}}else C(l,"Object3D")?(t=()=>h==null?void 0:h.remove(l),h==null||h.add(l)):Ge(d)&&(C(l,"Material")?d.material=l:C(l,"BufferGeometry")&&(d.geometry=l));e()});const i=o=>{r.set(o)},u=o=>{a.set(o),C(o,"Object3D")&&c.set(o)};return k(()=>{t==null||t(),e()}),{updateRef:u,updateAttach:i}},Xe=e=>C(e,"PerspectiveCamera")||C(e,"OrthographicCamera"),Je=()=>{const{invalidate:e,size:t,camera:r}=I(),s=w(),n=w(!0),a=w(!1);return v([s,a],([o,l])=>{!o||!l||(r.set(o),e())}),v([s,n,t],([o,l,d])=>{!o||l||(C(o,"OrthographicCamera")?(o.left=d.width/-2,o.right=d.width/2,o.top=d.height/2,o.bottom=d.height/-2,o.updateProjectionMatrix(),o.updateMatrixWorld(),e()):C(o,"PerspectiveCamera")&&(o.aspect=d.width/d.height,o.updateProjectionMatrix(),o.updateMatrixWorld(),e()))}),{updateRef:o=>{Xe(o)&&s.set(o)},updateManual:o=>{n.set(o)},updateMakeDefault:o=>{a.set(o)}}},Qe=e=>{let t,r,s=!1;const n=()=>{t==null||t(),t=e==null?void 0:e(r)},a=c=>{r=c,s&&n()};return Y(()=>{n(),s=!0}),k(()=>t==null?void 0:t()),{updateRef:a}},H=Symbol("threlte-disposable-object-context"),Ye=e=>typeof(e==null?void 0:e.dispose)=="function"&&!C(e,"Scene"),Ze=e=>{let t;const r=w(void 0),s=w(e),{disposableObjectMounted:n,disposableObjectUnmounted:a,removeObjectFromDisposal:c}=te(),i=b(H),u=P([s,i??w(!0)],([d,h])=>d??h??!0);return y(H,u),v([r,u],([d,h])=>{d===t?h?t&&n(t):t&&c(t):h&&(t&&a(t),d&&n(d)),t=d}),k(()=>{if(!N(u))return;const d=N(r);d&&a(d)}),{updateRef:d=>{Ye(d)&&r.set(d)},updateDispose:d=>{s.set(d)}}},Fe=e=>e!==null&&typeof e=="object"&&"addEventListener"in e&&"removeEventListener"in e,$e=(e={})=>{const t=n=>{var a;n!=null&&n.type&&((a=e[`on${n.type}`])==null||a.call(e,n))},r=(n,a)=>{const c=[];for(const i of Object.keys(a))i.startsWith("on")&&(n.addEventListener(i.slice(2),t),c.push(i));return()=>{for(let i=0;i<c.length;i++)n.removeEventListener(c[i],t)}};return{updateRef:n=>{if(Fe(n))return r(n,e)}}};let W;const et=e=>{W=e},tt=()=>{const e=W;return W=void 0,e},rt=e=>{const r=b("threlte-plugin-context");if(!r)return;const s=[],n=Object.values(r);if(n.length){const a=e();for(let c=0;c<n.length;c++){const i=n[c],u=i(a);u&&u.pluginProps&&s.push(...u.pluginProps)}}return{pluginsProps:s}},st=new Set(["$$scope","$$slots","type","args","attach","instance"]),nt=new Set(["fov","aspect","near","far","left","right","top","bottom","zoom"]),at=e=>typeof e=="string"||typeof e=="number"||typeof e=="boolean"||typeof e>"u"||e===null,G=(e,t,r)=>{var s,n,a;return!Array.isArray(r)&&typeof r=="number"&&typeof e[t]=="object"&&e[t]!==null&&typeof((s=e[t])==null?void 0:s.setScalar)=="function"&&!((n=e[t])!=null&&n.isColor)?(c,i,u)=>{c[i].setScalar(u)}:typeof((a=e[t])==null?void 0:a.set)=="function"&&typeof e=="object"&&e!==null?Array.isArray(r)?(c,i,u)=>{c[i].set(...u)}:(c,i,u)=>{c[i].set(u)}:(c,i,u)=>{c[i]=u}},ot=()=>{const{invalidate:e}=I(),t=new Map,r=new Map,s=(a,c,i,u)=>{if(at(i)){const d=t.get(c);if(d&&d.instance===a&&d.value===i)return;t.set(c,{instance:a,value:i})}const{key:o,target:l}=$(a,c);if(i!=null){const d=r.get(c);if(d)d(l,o,i);else{const h=G(l,o,i);r.set(c,h),h(l,o,i)}}else G(l,o,i)(l,o,i);u.manualCamera||nt.has(o)&&(l.isPerspectiveCamera||l.isOrthographicCamera)&&l.updateProjectionMatrix()};return{updateProp:(a,c,i,u)=>{var o;!st.has(c)&&!((o=u.pluginsProps)!=null&&o.includes(c))&&s(a,c,i,u),e()}}},ct=/^\s*class\s+/,it=e=>typeof e!="function"?!1:ct.test(e.toString()),ut=e=>Array.isArray(e),dt=(e,t)=>it(e)?ut(t)?new e(...t):new e:e;function K(e,t){xe(t,!0);let r=D(t,"is",19,tt),s=D(t,"manual",3,!1),n=D(t,"makeDefault",3,!1),a=D(t,"ref",15),c=Ve(t,["$$slots","$$events","$$legacy","is","args","attach","manual","makeDefault","dispose","ref","oncreate","children"]),i=Q(()=>dt(r(),t.args));const u=Qe(t.oncreate);V(()=>{a()!==x(i)&&(a(x(i)),u.updateRef(x(i)))});const o=rt(()=>({get ref(){return x(i)},get args(){return t.args},get attach(){return t.attach},get manual(){return s()},get makeDefault(){return n()},get dispose(){return t.dispose},get props(){return c}})),{updateProp:l}=ot();Object.keys(c).forEach(T=>{V(()=>{l(x(i),T,c[T],{manualCamera:s(),pluginsProps:o==null?void 0:o.pluginsProps})})});const d=qe();V(()=>d.updateAttach(t.attach)),V(()=>d.updateRef(x(i)));const h=Je();V(()=>h.updateRef(x(i))),V(()=>h.updateManual(s())),V(()=>h.updateMakeDefault(n()));const f=Ze(t.dispose);V(()=>f.updateRef(x(i))),V(()=>f.updateDispose(t.dispose));const S=$e(c);V(()=>S.updateRef(x(i)));var p=he(),m=ye(p);Se(m,()=>t.children??we,()=>({ref:x(i)})),me(e,p),ve()}const ne={},Dt=e=>{Object.assign(ne,e)},At=new Proxy(function(){},{apply(e,t,r){return K(...r)},get(e,t){if(typeof t!="string")return K;const r=ne[t]||fe[t];if(r===void 0)throw new Error(`No Three.js module found for ${t}. Did you forget to extend the catalogue?`);return et(r),K}});function Pt(e,t){const r="threlte-plugin-context";t&&y(r,{...b(r),[e]:t})}function Ot(e,t){const{scheduler:r}=I();return r.getStage(e)??r.createStage(e,t)}function It(e,t,r){const s=He();if(!s)throw new Error("No user context store found, did you invoke this function outside of your main <Canvas> component?");return e?e&&!t?P(s,n=>n[e]):(s.update(n=>{if(e in n){if(!r||r.existing==="skip")return n;if(r.existing==="merge"){const c=typeof t=="function"?t():t;return Object.assign(n[e],c),n}}const a=typeof t=="function"?t():t;return n[e]=a,n}),s.current[e]):{subscribe:s.subscribe}}function jt(e,t){const{remember:r,clear:s}=Re();let n;const a=()=>{var o;const u=new e(...(t==null?void 0:t.args)??[]);return(o=t==null?void 0:t.extend)==null||o.call(t,u),u};return{load:(u,o)=>{const l=async d=>{var h;if(n||(n=a()),"loadAsync"in n){const f=await n.loadAsync(d,o==null?void 0:o.onProgress);return((h=o==null?void 0:o.transform)==null?void 0:h.call(o,f))??f}else return new Promise((f,S)=>{n.load(d,p=>{var m;return f(((m=o==null?void 0:o.transform)==null?void 0:m.call(o,p))??p)},p=>{var m;return(m=o==null?void 0:o.onProgress)==null?void 0:m.call(o,p)},S)})};if(Array.isArray(u)){const d=u.map(f=>r(()=>l(f),[e,f]));return z(Promise.all(d))}else if(typeof u=="string"){const d=r(()=>l(u),[e,u]);return z(d)}else{const d=Object.values(u).map(f=>r(()=>l(f),[e,f]));return z(Promise.all(d).then(f=>Object.fromEntries(Object.entries(u).map(([S],p)=>[S,f[p]]))))}},clear:u=>{Array.isArray(u)?u.forEach(o=>{s([e,o])}):typeof u=="string"?s([e,u]):Object.entries(u).forEach(([o,l])=>{s([e,o,l])})},loader:n}}export{O as A,vt as B,C,z as D,Ae as E,wt as F,v as G,E as H,Oe as I,$ as J,Me as K,Ce as L,At as T,St as a,yt as b,Rt as c,Ne as d,Mt as e,Et as f,Vt as g,Ct as h,kt as i,Tt as j,Dt as k,Pt as l,Ot as m,Ue as n,It as o,jt as p,Re as q,ee as r,L as s,te as t,I as u,We as v,Le as w,_e as x,Be as y,se as z};
